---
title: dva的简单使用
date: 2020-06-20 00:00:00
categories: 'react'
tags:
- react
---
## dva简介
    拿出dva官网给出的简介 ---dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，
    所以也可以理解为一个轻量级的应用框架。
## dva的在项目中的使用  
```
首先我们会创建一个modal.js的文件来存放我们要共享的数据
export default {
    namespace: 'Modal'
    state: {
        count: 0
    }
    reducer：{
        changeCount(state, {payload}){
            ...state,
            count: payload
        }
    }
    effects: {
        // 当前定义的方法如果经过多次触发会取最后一次dispatch
        changeCount:[*function({payload}, {call, select, put}){ 'TODO'}, { type: 'takeLatest' }]
    }
}
```


namespace: model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过 . 的方式创建多层命名空间
state: 我们共享数据的初始值
reducers：以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方
effects：用于处理异步操作和业务逻辑，不直接修改 state。由 action 触发，可以触发 action，可以和服务器交互，可以获取全局 state 的数据等等。
[*(action, effects) => void, { type }] 这是effects为我们提供的几种类型  takeLatest throttle 这两种类型分别是多次相同的dispatch会合并成一个
而 throttle显而易见是节流防抖
      
## 组件中使用
```
function Component ({ count, dispatch}) {
    const changeCount (payload) {
        dispatch({
            type: 'namespace/changeCount',
             payload
        })
    }
    return (
        <div>修改状态</div>
    )
}

export default connect(({namespace}) => ({count}))(Component)
```     
 
## effects 处理
简单封装一个请求接口的方法
  async function getData(data) {
       return request("queryFromApi", {
           data,
           method: "post",
           dataType: "payload"
       })
   }

    namespace: 'Modal',
    state: {
        count: 0
    },
    effects: {
      * query({ payload }, { call, put }){+
           const { data } = yield call (getData, payload)
           if(data){
               yield put({
                   type: 'querySuccess',
                   payload: data
               })
           }       
       },
       * create(){},
       * remove(){},
       * update(){}
        
    },
    reducers: {
       querySuccess(state, {payload}){
           return {
               ...state
               count: payload
           }
       }       
    }

请求数据时候，发起异步请求，请求到数据之后，通过调用 reducers更新state。
dva 通过对 model 增加 effects 属性来处理异步任务，这是基于 redux-saga 实现的，
语法为 generator。Generator 返回的是迭代器，通过 yield 关键字实现暂停功能。
并触发一个Api调用以获取服务器数据。当每个action被发起时调用 call 和 put 都是 redux-saga 的 effects，call 表示调用异步函数，
put 表示 dispatch action，其他的还有 select, take, fork, cancel 等，select 则可以用来访问其它 model
  
  
  ## dva使用总结
  
  dva将所有与数据操作相关的逻辑集中放在一个地方处理和维护，在数据跟业务状态交互比较紧密的场景下，会使我们的代码更加清晰可控。
  写react的小伙伴可能知道antd的表单会通过Form.create()创建注入form表单当我们实现表单联动的时候，动态的增加删除表单的时候，可以试着将注入value和onChange的逻辑拿到redux中处理
  这样我们只关注开头和结尾的处理即可！
  由于要进行大量的数据操作，在设计model时将不同类型的业务需求数据操作分开处理，也达到了便于维护的目的
                                      



